\chapter{Supported language features}\label{supported_lang}

Because of the extent of the language we would like to support in the compiler, only a subset is implemented. The compiler is designed to be extensible, so it is possible to extend the supported features with reasonable effort. This chapter describes the language features that are currently supported by the compiler and notes important features whose support is missing.

The parser supports only a subset of valid programs. Notably, the parser does not support general Unicode code points in many places; a program is expected to be written only using the ASCII character set. The parser does not support automatic semicolon insertion. Although only select functions are compiled, the parser still has to be able to parse the entire input program which therefore needs to adhere to the limited grammar supported by the parser. The parser supports a slightly larger subset of the language than the rest of the compiler, however, because listing all the supported features of each part of the compiler would be too verbose, the differences are omitted from this text. The source code of the parser can serve as a reference for the supported language instead.

The ECMAScript 2023 Language Specification\cite{ecma262} often defines additional static semantics for many grammar productions. The compiler does not implement some of them and may produce a runnable program even if the static semantics are not satisfied -- such program may behave unexpectedly. In general, the input program is expected to be valid according to the specification for the compiler to behave correctly.


\section{Functions}

Only ordinary functions are supported by the runtime.

Because the behavior of a function can change by compiling it to native code, the compiler does not compile all functions in the input program. Instead, only functions that contain type annotations in their signature are compiled. This allows the programmer to make a conscious decision about which functions will be compiled. These functions will always be compiled and if their compilation fails, the input program will not be executed.

As described in Section \ref{impl:stubs}, functions from a single script that are compiled to native code are statically linked together. While the semantics is then different from the semantics of standard JavaScript, it could be implemented without any changes to QuickJS, and makes the resulting code run faster.

Compiled functions exist in an isolated space, where they can interact only with each other and their arguments. Notably, the lexical scope visible from these functions does not extend past the function body. The function code can therefore not interact with global variables or implicitly with the global object. It is, on the other hand, possible to pass any data (including the global object) as explicit parameters of a function and interact with them this way.

Compiled functions also do not have access to the \texttt{arguments} object and the \texttt{this} binding.


\section{Types}

All types specified in Section \ref{ir:types} except for the types \texttt{StringConst} and \texttt{Void} can be used for variables, function arguments, and as a return type. The type \texttt{StringConst} only exists internally in the compiler and is used to represent string literals. The type \texttt{Void} can be used only as a return type of a function.


\section{Variable and function declarations}

The compiler supports only lexical variable declarations. It supports only ordinary function declarations (i.e., no generators, async functions, and arrow functions). In the context of a function which is to be compiled, all arguments, return values, and local variables must have a type annotation.

In general, \textit{binding pattern} and \textit{binding rest element} is not supported. The compiler supports only the use of simple identifiers for arguments and variable declarations.


\section{Identifiers}

Various structures in the language are identified by their name. JavaScript specifies a list of conditionally reserved words which cannot be used as identifiers. The compiler does not implement these rules and instead disallows the use of any reserved word\footnotemark[1] as an identifier. Identifiers also do not support the use of Unicode escape sequences.

\footnotetext[1]{As specified in the grammar production \texttt{ReservedWord} in Section 12.7.2 of the ECMAScript 2023 Language Specification\cite{ecma262}.}


\section{Literals}

Standard JavaScript numeric, boolean and string literals are supported. A change of semantics is made to numeric literals. Numeric literals which can be represented as 32-bit integers represent a value of the type \texttt{int32}. Remaining numeric literals are represented as a value of the type \texttt{float64}. This type is then used to select the correct behavior of an operation the literal is used in. Legacy octal integer literals (i.e., literals starting with a zero) are not supported.

String literals do not support all escape sequences.

Notable literals that are not supported are object literals, array literals, and regular expression literals. These are not supported even by the parser therefore may not be used anywhere in the input program. The creation of these objects must therefore be performed by calling their corresponding constructor and by setting each property individually.


\section{Operators}

Arithmetic and bitwise operators are implemented according to the modified semantics described in Section \ref{language}\todo{move spec there?}.

Relational operators, and logical (short-circuit) operators are supported with limited operand types. Relational operators only support operands of the types \texttt{int32}, \texttt{float64}, and \texttt{boolean}. Short-circuit operators only support operands of the type \texttt{boolean}.

Update expressions (i.e., \texttt{++} and \texttt{{-}{-}}) are supported in both prefix and postfix forms. Keyword operators (i.e., \texttt{instanceof}, \texttt{in}, \texttt{typeof}, \texttt{void}, and \texttt{delete}) are, on the contrary, not supported.

Member access operators (i.e., \texttt{.} and \texttt{[]}) are supported only for operands \texttt{Object} for the object and text literal or \texttt{int32} for the identifier. The \texttt{.?} operator is not supported.

Operators \texttt{??}, \texttt{===}, \texttt{!==} are not supported.\todo{rewrite}


\section{Control flow}

The compiler supports the following control flow statements:
\begin{itemize}
    \item \texttt{if} statement,
    \item \texttt{while} statement,
    \item \texttt{do while} statement,
    \item \texttt{for} statement,
    \item \texttt{break} statement,
    \item \texttt{continue} statement,
    \item \texttt{return} statement,
    \item \texttt{throw} statement.
\end{itemize}


\section{Exceptions}

Exceptions are partially supported by the compiler. If an exception is thrown from an expression or a statement, the exception will be propagated to the caller of the compiled function.

The \texttt{try} statement is not supported, and it is not to perform any exception handling in the compiled code.





% To create an equivalent machine code, numeric values should be represented as \texttt{Float64}, or \texttt{Any}\footnotemark[3]

% \footnotetext[3]{The performance of arithmetic operations on different types may vary depending on the target CPU -- for example, on a 32-bit CPU without 64-bit float acceleration, work with small integer values will be significantly faster when the \texttt{Any} type is used instead of \texttt{Float64}.}
