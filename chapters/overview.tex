\chapter{Overview}

The goal of this thesis is to implement a simple compiler for a subset of TypeScript. This chapter describes the high-level architecture of the compiler, and related technologies used or considered for its implementation.

\section{Requirements}

The proposed compiler will be primarily used in restricted environments such as microcontrollers or single board computers. For this reason, the compiler must be small and resource efficient. The compiler will be used as a part of the JavaScript runtime Jaculus (described in Section \ref{jaculus}).

\todo{ask}
Because the compiler should be simple, it will only perform static analysis and compilation of selected parts of the input program. After the compilation is completed, the compiler will not perform any further work during the execution of the program. The compilation will be performed at the level of functions. If multiple suitable functions are found in a single file, they will be compiled together and statically linked.

The compiler must be able to compile a subset of TypeScript that will make it possible to write useful subroutines that can make use of the increased performance of compiled code. Initially, the compiler will support only a small part of the language, but it should be possible to extend the compiler in the future.

Examples of programs that should be able to take advantage of the compiler are:\todo{extend list?}
\begin{itemize}
    \item computational functions,
    \item functions for graphical rendering,
    \item inner computations of more complex functions.
\end{itemize}

\section{Architecture}

The compiler is separated into multiple phases, each of which is responsible for a single step of the compilation process. The compiler is designed to depend on external libraries as weakly as possible. This means that it is possible to replace these libraries with other implementations without an extensive rewrite of the compiler (particularly the compiler backend MIR, and the JavaScript engine QuickJS).

\todo{add a diagram of the architecture}


\section{Related technologies}

Multiple other projects were used for the implementation of the proposed compiler. These projects are described in this section. This section also describes multiple small compiler backends which were considered as candidate options.

\subsection{Jaculus}\label{jaculus}

Jaculus was originally created as a part of the author's bachelor's thesis\cite{jaculusthesis}. This work is a continuation of the project.

Jaculus is a platform for programming microcontrollers using JavaScript. At its core, Jaculus uses the QuickJS JavaScript engine. Jaculus' core library, Jaculus-machine, is of particular interest for this work, as the proposed compiler is implemented as an extension of this library. Jaculus-machine implements high-level C++ abstractions around QuickJS and implements some core features for the runtime (e.g., an event loop, or file system interactions).
\todo{rewrite, more context}


\subsection{QuickJS}

QuickJS is an embeddable JavaScript engine created by Fabrice Bellard and other contributors\cite{quickjs}. The version used in the current version of Jaculus-machine implements the ECMAScript 2023 Language Specification\cite{ecma262}.

QuickJS is designed to have a small code and memory footprint, and to be easily embeddable in larger programs. An important target of QuickJS is to have a very short startup time.

QuickJS uses a stack-based bytecode machine. To reduce the startup time, QuickJS generates bytecode while parsing the source code without the use of an intermediate representation or AST. Some simple optimizations are then performed on the generated bytecode.

Values in JavaScript have a dynamic type, which may fall into one of several categories. In QuickJS, values are represented using a tagged union -- a structure with two 64-bit values representing the tag and a value.

Some primitive values are placed directly into this structure while others are allocated on the heap and the structure only contains a pointer to the value. Values which require memory allocation use reference counting with cycle detection for memory management.

\todo{expand}


\subsection{Compiler backends}

\todo{write}

\subsubsection{MIR}

MIR is a small compiler backend designed for usage in JIT scenarios.
