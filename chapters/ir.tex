\chapter{Intermediate Representation}\label{ir}

This chapter describes the first intermediate representation which is generated by the compiler from an abstract syntax tree (AST).

The intermediate representation describes individual functions in the form of a control-flow graph (CFG). A CFG typically consists of basic blocks which form small chunks of non-branching code\footnote{The code is non-branching at the level of individual instructions. Some operations may result in exceptions and terminate the execution of function early.}. Each basic block ends with a terminator instruction which can perform a (possibly conditional) jump to a different basic block, or terminate the entire function. Together, basic blocks (nodes) with terminator instructions (edges) form a directed graph which represents all possible paths through the program.

The semantics of the program described using this intermediate representation is defined in the form of an abstract virtual machine which can execute this code.


\section{Virtual machine semantics}

The state of the virtual machine consists of:
\begin{itemize}
    \item program code,
    \item an instruction pointer,
    \item an unlimited number of virtual registers,
    \item a cleanup stack, and
    \item a reference to a JavaScript interpreter.
\end{itemize}

The virtual machine can execute a single function with given arguments. Each execution step performs a single instruction at the position of the instruction pointer and updates the instruction pointer accordingly. A \texttt{Call} instruction is not processed by the same machine. Instead, the virtual machine is paused until the call is finished by the correct means (e.g., as a native call, in a new virtual machine).

To simplify the process of generating the IR, the virtual machine uses an unlimited number of virtual registers. These will be referred to as \textit{IR registers}. IR registers should not be confused with CPU registers, as they can hold different, and more complex value types (i.e., JavaScript's dynamic type), and are only later mapped into physical memory or CPU registers. IR registers are statically typed and can take on the types described in Section \ref{ir:types}. Each register has a unique identifier represented by a numeric value.

A cleanup stack allows the program to simplify the management of value ownership. When the reference count of a value should be reduced, it is not done directly -- instead, the value is placed onto the cleanup stack and its reference count is reduced at the exit of the function. This approach allows for simpler usage analysis of values.

Some instructions need to interact with the underlying JavaScript virtual machine to perform the operation which they represent. A reference to the JavaScript virtual machine must be therefore accessible. The model does not specify how the JS VM will be available, but two possible approaches would be:
\begin{itemize}
    \item a constant in static memory -- a function is bound to a JS VM at compile time, or
    \item through a function parameter -- a function may be shared with multiple JS VMs.
\end{itemize}


\section{IR Types}\label{ir:types}

IR registers can take on a subset of the types described in Section \ref{lang:types}. These are both standard JavaScript types and newly introduced primitive types. Aside from these, two more types are used in the IR -- \texttt{StringConst} and \texttt{Void}. The type \texttt{Void} represents the lack of a value and registers of this type may not be used as operands of most instructions. In return type, it is equivalent to the type \texttt{Undefined}. The list of available types can be seen in Table \ref{tab:types}.
\todo{Void kinda untrue}

\begin{table}[H]
    \centering
    \begin{tabular}{l | l}
        Type name            & Possible values                                                \\\hline
        \texttt{Void}        & the JavaScript value \texttt{undefined}                        \\
        \texttt{Int32}       & Signed 32-bit integer number                                   \\
        \texttt{Float64}     & IEEE 754-2019 double-precision floating point number           \\
        \texttt{Boolean}     & true/false                                                     \\
        \texttt{Object}      & Reference to a JavaScript Object (primitive type not           \\
                             & allowed)  \\
        \texttt{StringConst} & Reference to a static string value (e.g., a literal)           \\
        \texttt{Any}         & Value of JavaScript's dynamic type (type union)
    \end{tabular}
    \caption{Possible types of intermediate registers}
    \label{tab:types}
\end{table}


\section{IR Instructions}

IR instructions represent simple operations and may have different variants based on types of their operands. Most instructions correspond to different operations from our modified JavaScript as described in Chapter \ref{language}. There are four kinds of instructions:


\texttt{Operation} represents a simple instruction with up to three operands (typically 2 inputs and 1 output) and may perform different operations depending on their argument types. All required operands must be valid IR registers.\todo{rename}

\texttt{ConstInit} performs a constant initialization of an IR register. They only have two operands -- an IR register, and an immediate value. The types of these values correspond to primitive value literals -- i.e., \texttt{Boolean}, \texttt{Int32}, \texttt{Float64}, \texttt{StringConst}.

\texttt{Call} represents a function call. It can have a variable number of parameters and can describe a native function call or JavaScript function call. All operands representing arguments and return value target must be IR registers. The call target may either be a string identifier of a native function, or an IR register containing a function object. If the call target is a native function, the types of the arguments and return IR registers must correspond to the types of the native function. If the call target is a JavaScript function, the first argument specifies the value of \texttt{this} binding, and the return IR register must be of the type \texttt{Any}.

\texttt{Terminator} terminates a basic block. They can be used to describe control flow. Available terminators are: \texttt{Jump}, \texttt{Branch}, \texttt{Return}, \texttt{ReturnValue}, and \texttt{Throw}. There must be exactly one terminator instruction in each basic block.

All Operations are listed in Table \ref{tab:opcodes}. The behavior of each Operation follows the semantics of the JavaScript language as described in Section \ref{lang:semantics}. A difference is that while the JavaScript specification describes every operation with dynamic argument types and type coercion is performed by the operation, the IR instructions are statically typed and expect the arguments to be already coerced to the correct types.

The Operations \texttt{Dup} and \texttt{PushFree}\footnotemark[1] are used for updating the reference counts\footnotemark[2] of JavaScript values. To simplify the process of decreasing the reference counts, a cleanup stack is used at runtime. The \texttt{Dup} instruction immediately increments the reference count of a value, whereas the \texttt{PushFree} instruction only pushes the value to the "cleanup" stack, which is used in function's epilogue to decrease the reference counts of all values used during its runtime..

\footnotetext[1]{The names \texttt{Dup} and \texttt{Free} are not entirely descriptive of the operation which they perform, however, an equivalent operation in QuickJS is performed by a pair of functions \texttt{JS\_DupValue} and \texttt{JS\_FreeValue}, from which the names are derived.}

\footnotetext[2]{While we talk about reference counts of values, the interface is not limited to this memory management approach. In practice, the underlying JavaScript interpreter may use a different algorithm (such as mark-and-sweep). In essence \texttt{Dup} and \texttt{PushFree} instructions only describe the action of taking and releasing the ownership of a value.}


\begin{table}
    \centering
    \begin{tabular}{l | l | l}
        \texttt{Opcode}      & Signature \texttt{(a b -> res)}    &  Meaning                    \\\hline
        \texttt{Add}         & \texttt{a      a     -> a        } &  Addition                   \\
        \texttt{Sub}         & \texttt{a      a     -> a        } &  Subtraction                \\
        \texttt{Mul}         & \texttt{a      a     -> a        } &  Multiplication             \\
        \texttt{Div}         & \texttt{a      a     -> a        } &  Division                   \\
        \texttt{Rem}         & \texttt{a      a     -> a        } &  Remainder                  \\
        \texttt{Pow}         & \texttt{a      a     -> a        } &  Exponentiation             \\
        \texttt{UnPlus}      & \texttt{a      \_    -> a        } &  Unary plus                 \\
        \texttt{UnMinus}     & \texttt{a      \_    -> a        } &  Unary minus                \\
                             & \texttt{a = Int32 | Float64 | Any} &                             \\\hline
        \texttt{LShift}      & \texttt{Int32  Int32 -> Int32    } &  Left shift                 \\
        \texttt{RShift}      & \texttt{Int32  Int32 -> Int32    } &  Right shift                \\
        \texttt{URShift}     & \texttt{Int32  Int32 -> Int32    } &  Unsigned right shift       \\
        \texttt{BitAnd}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise AND                \\
        \texttt{BitOr}       & \texttt{Int32  Int32 -> Int32    } &  Bitwise OR                 \\
        \texttt{BitXor}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise XOR                \\
        \texttt{BitNot}      & \texttt{Int32  \_    -> Int32    } &  Bitwise negation           \\\hline
        \texttt{Eq}          & \texttt{a      a     -> Boolean  } &  Equality                   \\
        \texttt{Neq}         & \texttt{a      a     -> Boolean  } &  Non-equality               \\
        \texttt{Gt}          & \texttt{a      a     -> Boolean  } &  Greater than               \\
        \texttt{Gte}         & \texttt{a      a     -> Boolean  } &  Greater-or-equal           \\
        \texttt{Lt}          & \texttt{a      a     -> Boolean  } &  Less than                  \\
        \texttt{Lte}         & \texttt{a      a     -> Boolean  } &  Less-or-equal              \\
        \texttt{BoolNot}     & \texttt{a      \_    -> Boolean  } &  Logical negation           \\\hline
        \texttt{GetMember}   & \texttt{parent id    -> Any      } &  Get member                 \\
        \texttt{SetMember}   & \texttt{id     a     -> parent   } &  Set member                 \\
                             & \texttt{id = StringConst | Int32 } &                             \\
                             & \texttt{parent = Object | Any    } &                             \\\hline
        \texttt{Set}         & \texttt{a      \_    -> b        } &  Convert, set IR register   \\
        \texttt{Dup}         & \texttt{a      \_    -> \_       } &  Increment reference count  \\
        \texttt{PushFree}    & \texttt{a      \_    -> \_       } &  Push to the cleanup stack  \\
    \end{tabular}
    \caption{Table: List of Operations. The column signature shows the possible types of IR registers used as operands. Most Operations have three operands -- two inputs and one output. Therefore, the three operands are denoted as \texttt{a b -> res}. Type placeholders are used to show all possible overloaded variants of a given Operation. The placeholder \texttt{\_} describes an unused operand. The syntax \texttt{id = StringConst | Int32} describes a type alias \texttt{id} which can take on the listed types (\texttt{StringConst} or \texttt{Int32}). }
    \label{tab:opcodes}
\end{table}
\todo{fix type placeholders in \ref{tab:opcodes}}


\section{IR interpreter}

An interpreter for the intermediate representation is available as part of the test suite to allow for testing of the generated IR without compiling it to native code. It allows for catching IR generation errors early and testing the compiler without later phases. The interpreter works directly with the IR registers and keeps track of their types and reference counts during the runtime. Reference counts are updated for all types of values, including all primitive values, which allows for checking the correctness of the generated code.
