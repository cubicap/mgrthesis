\chapter{Intermediate Representation}\label{ir}

This chapter describes an intermediate representation which is generated by the compiler from an abstract syntax tree (AST). This representation is used to flatten the hierarchical structure of the AST and to simplify the process of generating native code.

The intermediate representation describes individual functions in the form of a control-flow graph (CFG). This CFG consists of basic blocks which form small chunks of non-branching code\footnote{The code is non-branching at the level of individual instructions. Some operations may result in exceptions and terminate the execution of function early.}. Each basic block ends with a terminator instruction which can perform a (possibly conditional) jump to a different basic block, or terminate the function. Together, basic blocks (nodes) with terminator instructions (edges) form a directed graph which represents all possible paths through the program.

The semantics of a program described using this intermediate representation is defined in the form of an abstract virtual machine.


\section{Virtual machine semantics}\label{ir:vm}

The state of the virtual machine consists of a shared part:
\begin{itemize}
    \item program code (immutable),
    \item state of JavaScript objects,
\end{itemize}

\noindent
and a private part:
\begin{itemize}
    \item an instruction pointer,
    \item an unlimited number of virtual registers,
    \item a cleanup pool.
\end{itemize}

The virtual machine can execute a single function with given arguments. Each execution step evaluates a single instruction at the position of the instruction pointer and updates the instruction pointer accordingly. A \texttt{Call} instruction is not processed by the same machine. Instead, the virtual machine is paused until the call is finished by the respective means (e.g., as a native call, or in a new virtual machine).

To simplify the process of generating the IR, the virtual machine has an unlimited number of virtual registers. These will be referred to as \textit{IR registers}. IR registers are different from CPU registers, as they can also hold aggregate types (i.e., JavaScript's dynamic type), and are only later mapped into memory or CPU registers. IR registers are statically typed and can take on the types described in the next section. Each register has a unique identifier represented by a numeric value.

A cleanup pool allows the program to simplify the management of value ownership. When the reference count of a value should be decreased, it is not decreased immediately -- instead, the value is placed into the cleanup pool and its reference count is decreased at the exit of the function. This approach allows for simpler usage analysis of values.


\section{Types}\label{ir:types}

IR registers have static types. Most of the types correspond to the available type annotations described in Section \ref{lang:types}. The type \texttt{Void} represents the lack of a value and registers of this type may not be used as operands of most instructions. In return type, it is equivalent to the type \texttt{Undefined}. The list of available types can be seen in Table \ref{tab:types}.

\begin{table}[H]
    \centering
    \begin{tabular}{l | l}
        Type name            & Possible values                                                \\\hline
        \texttt{Void}        & JavaScript value \texttt{undefined}, return type only          \\
        \texttt{Int32}       & Signed 32-bit integer number                                   \\
        \texttt{Float64}     & IEEE 754-2019 double-precision floating point number           \\
        \texttt{Boolean}     & true/false                                                     \\
        \texttt{Object}      & Reference to a JavaScript Object (primitive type not           \\
                             & allowed)  \\
        \texttt{StringConst} & Reference to a static string value (e.g., a literal)           \\
        \texttt{Any}         & Value of JavaScript's dynamic type (tagged union)
    \end{tabular}
    \caption{Possible types of intermediate registers}
    \label{tab:types}
\end{table}


\section{Instructions}

Instructions in the intermediate representation describe individual operations in the execution of a program. Most of the instructions correspond to different operations from our modified JavaScript as described in Chapter \ref{language}. These operations may have different behavior depending on the types of their operands -- an opcode essentially describes an overload set. There are four kinds of instructions:

Simple instructions with up to three operands (typically 2 inputs and 1 output) which are listed in Table \ref{tab:opcodes}. All required operands must be valid IR registers. Their behavior follows the semantics of our language as described in Section \ref{lang:semantics}. A difference is that while ES-262 \cite{ecma262} describes every operation with dynamic operand types and type coercion is performed by the operation, IR instructions expect the operands to be already coerced to a common type.

\texttt{ConstInit} instruction performs a constant initialization of an IR register. They only have two operands -- an IR register, and an immediate value. The types of these values correspond to primitive value literals -- i.e., \texttt{Boolean}, \texttt{Int32}, \texttt{Float64}, \texttt{StringConst}.

\texttt{Call} instruction represents a function call. Unlike the other instruction types, it has a variable number of operands, depending on the function which is being called. It can describe a native function call or a JavaScript function call. All operands representing arguments and return value target must be IR registers. The call target may either be a string identifier of a native function or an IR register containing a function object. If the call target is a native function, the types of arguments and return IR registers must correspond to the signature of the native function. If the call target is a JavaScript function, the first argument specifies the value of \texttt{this} binding, and the return IR register must be of the type \texttt{Any}.

\texttt{Terminator} instruction terminates a basic block. They are used describe control flow. Available terminators are: \texttt{Jump}, \texttt{Branch}, \texttt{Return}, and \texttt{Throw}. There must be exactly one terminator instruction at the end of each basic block.

Instructions \texttt{Dup} and \texttt{PushUnref} are used for updating the reference counts\footnotemark[1] of JavaScript values. To simplify the process of decreasing the reference counts, a cleanup pool is used at runtime. The \texttt{Dup} instruction immediately increments the reference count of a value, whereas the \texttt{PushUnref} instruction only pushes the value to the cleanup pool, which is used in function's epilogue to decrease the reference counts of all values used during its runtime.

\footnotetext[1]{While we talk about reference counts of values, the interface is not limited to this memory management approach. In essence \texttt{Dup} and \texttt{PushUnref} instructions only describe the action of taking and releasing the shared ownership of a value.}


\begin{table}
    \centering
    \begin{tabular}{l | l | l}
        \texttt{Opcode}      & Signature \texttt{(a b -> res)}    &  Meaning                    \\\hline
        \texttt{Add}         & \texttt{n      n     -> n        } &  Addition                   \\
        \texttt{Sub}         & \texttt{n      n     -> n        } &  Subtraction                \\
        \texttt{Mul}         & \texttt{n      n     -> n        } &  Multiplication             \\
        \texttt{Div}         & \texttt{n      n     -> n        } &  Division                   \\
        \texttt{Rem}         & \texttt{n      n     -> n        } &  Remainder                  \\
        \texttt{Pow}         & \texttt{n      n     -> n        } &  Exponentiation             \\
        \texttt{UnPlus}      & \texttt{n      \_    -> n        } &  Unary plus                 \\
        \texttt{UnMinus}     & \texttt{n      \_    -> n        } &  Unary minus                \\
                             & \texttt{n = Int32 | Float64 | Any} &                             \\\hline
        \texttt{LShift}      & \texttt{Int32  Int32 -> Int32    } &  Left shift                 \\
        \texttt{RShift}      & \texttt{Int32  Int32 -> Int32    } &  Right shift                \\
        \texttt{URShift}     & \texttt{Int32  Int32 -> Int32    } &  Unsigned right shift       \\
        \texttt{BitAnd}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise AND                \\
        \texttt{BitOr}       & \texttt{Int32  Int32 -> Int32    } &  Bitwise OR                 \\
        \texttt{BitXor}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise XOR                \\
        \texttt{BitNot}      & \texttt{Int32  \_    -> Int32    } &  Bitwise negation           \\\hline
        \texttt{Eq}          & \texttt{a      a     -> Boolean  } &  Equality                   \\
        \texttt{Neq}         & \texttt{a      a     -> Boolean  } &  Non-equality               \\
        \texttt{Gt}          & \texttt{a      a     -> Boolean  } &  Greater than               \\
        \texttt{Gte}         & \texttt{a      a     -> Boolean  } &  Greater-or-equal           \\
        \texttt{Lt}          & \texttt{a      a     -> Boolean  } &  Less than                  \\
        \texttt{Lte}         & \texttt{a      a     -> Boolean  } &  Less-or-equal              \\
        \texttt{BoolNot}     & \texttt{a      \_    -> Boolean  } &  Logical negation           \\\hline
        \texttt{GetMember}   & \texttt{parent id    -> Any      } &  Get member                 \\
        \texttt{SetMember}   & \texttt{id     a     -> parent   } &  Set member                 \\
                             & \texttt{id = StringConst | Int32 } &                             \\
                             & \texttt{~~~~~| Any                 } &                             \\
                             & \texttt{parent = Object | Any    } &                             \\\hline
        \texttt{Set}         & \texttt{a      \_    -> b        } &  Convert, set IR register   \\
        \texttt{Dup}         & \texttt{a      \_    -> \_       } &  Increment reference count  \\
        \texttt{PushUnref}   & \texttt{a      \_    -> \_       } &  Push to the cleanup pool  \\
    \end{tabular}
    \caption{Table: List of simple instructions. The column \textit{signature} shows the possible types of IR registers used as operands. Most of these instructions have three operands -- two inputs and one output. Therefore, the three operands are denoted as \texttt{a b -> res}. Type placeholders are used to show all possible overloaded variants of a given instruction. The placeholder \texttt{\_} describes an unused operand. The syntax \texttt{x = y | z} describes a type alias \texttt{x} which can take on the listed types (\texttt{y} or \texttt{z}). }
    \label{tab:opcodes}
\end{table}


\section{IR interpreter}

An interpreter for the intermediate representation is available as part of the test suite to allow for testing of the generated IR without compiling it to native code. It allows for catching IR generation errors early and testing the compiler without executing later compilation phases. The interpreter works directly with IR registers and keeps track of their types and reference counts during runtime. Reference counts are updated for all types of values, including all primitive values, which allows for checking correctness of generated code.

The interpreter interacts with QuickJS to keep track of JavaScript objects. Some operations (e.g., arithmetic) are performed directly by the interpreter, while others (e.g., member access) are performed by calling QuickJS functions.
