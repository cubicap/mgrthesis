\chapter{Intermediate Representation}\label{ir}

This chapter describes the first intermediate representation which is generated by the compiler from an abstract syntax tree (AST).

The intermediate representation describes individual functions in the form of a control-flow graph (CFG). Our CFG consists of basic blocks which form small chunks of non-branching code\footnote{The code is non-branching at the level of individual instructions. Some operations may result in exceptions and terminate the execution of function early.}. Each basic block ends with a terminator instruction which can perform a (possibly conditional) jump to a different basic block, or terminate the entire function. Together, basic blocks (nodes) with terminator instructions (edges) form a directed graph which represents all possible paths through the program.

The semantics of a program described using this intermediate representation is defined in the form of an abstract virtual machine which can execute this code.


\section{Virtual machine semantics}\label{ir:vm}

The state of the virtual machine consists of:
\begin{itemize}
    \item program code,
    \item an instruction pointer,
    \item an unlimited number of virtual registers,
    \item a cleanup stack, and
    \item state of JavaScript objects.
\end{itemize}

The virtual machine can execute a single function with given arguments. Each execution step performs a single instruction at the position of the instruction pointer and updates the instruction pointer accordingly. A \texttt{Call} instruction is not processed by the same machine. Instead, the virtual machine is paused until the call is finished by the correct means (e.g., as a native call, or in a new virtual machine).

To simplify the process of generating the IR, the virtual machine uses an unlimited number of virtual registers. These will be referred to as \textit{IR registers}. IR registers should not be confused with CPU registers, as they can also hold aggregate types (i.e., JavaScript's dynamic type), and are only later mapped into memory or CPU registers. IR registers are statically typed and can take on the types described in Section \ref{ir:types}. Each register has a unique identifier represented by a numeric value.

A cleanup stack allows the program to simplify the management of value ownership. When the reference count of a value should be reduced, it is not done directly -- instead, the value is placed onto the cleanup stack and its reference count is reduced at the exit of the function. This approach allows for simpler usage analysis of values.


\section{IR Types}\label{ir:types}

IR registers can take on a subset of the types described in Section \ref{lang:types}. These are both standard JavaScript types and newly introduced primitive types. Aside from these, two more types are used in the IR -- \texttt{StringConst} and \texttt{Void}. The type \texttt{Void} represents the lack of a value and registers of this type may not be used as operands of most instructions. In return type, it is equivalent to the type \texttt{Undefined}. The list of available types can be seen in Table \ref{tab:types}.

\begin{table}[H]
    \centering
    \begin{tabular}{l | l}
        Type name            & Possible values                                                \\\hline
        \texttt{Void}        & JavaScript value \texttt{undefined}, return type only          \\
        \texttt{Int32}       & Signed 32-bit integer number                                   \\
        \texttt{Float64}     & IEEE 754-2019 double-precision floating point number           \\
        \texttt{Boolean}     & true/false                                                     \\
        \texttt{Object}      & Reference to a JavaScript Object (primitive type not           \\
                             & allowed)  \\
        \texttt{StringConst} & Reference to a static string value (e.g., a literal)           \\
        \texttt{Any}         & Value of JavaScript's dynamic type (type union)
    \end{tabular}
    \caption{Possible types of intermediate registers}
    \label{tab:types}
\end{table}


\section{IR Instructions}

Instructions in the intermediate representation describe individual operations describing the execution of a program. Most of the instructions correspond to different operations from our modified JavaScript as described in Chapter \ref{language}. These instructions may have different behavior depending on the types of their operands -- an instruction name essentially describes an overload set. There are four kinds of instructions:


Simple instructions with up to three operands (typically 2 inputs and 1 output) which are listed in Table \ref{tab:opcodes}. They may perform different operations depending on their argument types. All required operands must be valid IR registers.\todo{bruh} Their behavior follows the semantics of the JavaScript language as described in Section \ref{lang:semantics}. A difference is that while the JavaScript specification describes every operation with dynamic argument types and type coercion is performed by the operation, the IR instructions are statically typed and expect the arguments to be already coerced to the correct types.

\texttt{ConstInit} performs a constant initialization of an IR register. They only have two operands -- an IR register, and an immediate value. The types of these values correspond to primitive value literals -- i.e., \texttt{Boolean}, \texttt{Int32}, \texttt{Float64}, \texttt{StringConst}.

\texttt{Call} represents a function call. It can have a variable number of parameters and can describe a native function call or JavaScript function call. All operands representing arguments and return value target must be IR registers. The call target may either be a string identifier of a native function, or an IR register containing a function object. If the call target is a native function, the types of the arguments and return IR registers must correspond to the types of the native function. If the call target is a JavaScript function, the first argument specifies the value of \texttt{this} binding, and the return IR register must be of the type \texttt{Any}.

\texttt{Terminator} terminates a basic block. They can be used to describe control flow. Available terminators are: \texttt{Jump}, \texttt{Branch}, \texttt{Return}, \texttt{ReturnValue}, and \texttt{Throw}. There must be exactly one terminator instruction in each basic block.

Instructions \texttt{Dup} and \texttt{PushUnref} are used for updating the reference counts\footnotemark[1] of JavaScript values. To simplify the process of decreasing the reference counts, a cleanup stack is used at runtime. The \texttt{Dup} instruction immediately increments the reference count of a value, whereas the \texttt{PushUnref} instruction only pushes the value to the cleanup stack, which is used in function's epilogue to decrease the reference counts of all values used during its runtime.

\footnotetext[1]{While we talk about reference counts of values, the interface is not limited to this memory management approach. In practice, the underlying JavaScript interpreter may use a different algorithm (such as mark-and-sweep). In essence \texttt{Dup} and \texttt{PushUnref} instructions only describe the action of taking and releasing the ownership of a value.}


\begin{table}
    \centering
    \begin{tabular}{l | l | l}
        \texttt{Opcode}      & Signature \texttt{(a b -> res)}    &  Meaning                    \\\hline
        \texttt{Add}         & \texttt{n      n     -> n        } &  Addition                   \\
        \texttt{Sub}         & \texttt{n      n     -> n        } &  Subtraction                \\
        \texttt{Mul}         & \texttt{n      n     -> n        } &  Multiplication             \\
        \texttt{Div}         & \texttt{n      n     -> n        } &  Division                   \\
        \texttt{Rem}         & \texttt{n      n     -> n        } &  Remainder                  \\
        \texttt{Pow}         & \texttt{n      n     -> n        } &  Exponentiation             \\
        \texttt{UnPlus}      & \texttt{n      \_    -> n        } &  Unary plus                 \\
        \texttt{UnMinus}     & \texttt{n      \_    -> n        } &  Unary minus                \\
                             & \texttt{n = Int32 | Float64 | Any} &                             \\\hline
        \texttt{LShift}      & \texttt{Int32  Int32 -> Int32    } &  Left shift                 \\
        \texttt{RShift}      & \texttt{Int32  Int32 -> Int32    } &  Right shift                \\
        \texttt{URShift}     & \texttt{Int32  Int32 -> Int32    } &  Unsigned right shift       \\
        \texttt{BitAnd}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise AND                \\
        \texttt{BitOr}       & \texttt{Int32  Int32 -> Int32    } &  Bitwise OR                 \\
        \texttt{BitXor}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise XOR                \\
        \texttt{BitNot}      & \texttt{Int32  \_    -> Int32    } &  Bitwise negation           \\\hline
        \texttt{Eq}          & \texttt{a      a     -> Boolean  } &  Equality                   \\
        \texttt{Neq}         & \texttt{a      a     -> Boolean  } &  Non-equality               \\
        \texttt{Gt}          & \texttt{a      a     -> Boolean  } &  Greater than               \\
        \texttt{Gte}         & \texttt{a      a     -> Boolean  } &  Greater-or-equal           \\
        \texttt{Lt}          & \texttt{a      a     -> Boolean  } &  Less than                  \\
        \texttt{Lte}         & \texttt{a      a     -> Boolean  } &  Less-or-equal              \\
        \texttt{BoolNot}     & \texttt{a      \_    -> Boolean  } &  Logical negation           \\\hline
        \texttt{GetMember}   & \texttt{parent id    -> Any      } &  Get member                 \\
        \texttt{SetMember}   & \texttt{id     a     -> parent   } &  Set member                 \\
                             & \texttt{id = StringConst | Int32 } &                             \\
                             & \texttt{~~~~~| Any                 } &                             \\
                             & \texttt{parent = Object | Any    } &                             \\\hline
        \texttt{Set}         & \texttt{a      \_    -> b        } &  Convert, set IR register   \\
        \texttt{Dup}         & \texttt{a      \_    -> \_       } &  Increment reference count  \\
        \texttt{PushUnref}   & \texttt{a      \_    -> \_       } &  Push to the cleanup stack  \\
    \end{tabular}
    \caption{Table: List of simple instructions. The column \textit{signature} shows the possible types of IR registers used as operands. Most of these instructions have three operands -- two inputs and one output. Therefore, the three operands are denoted as \texttt{a b -> res}. Type placeholders are used to show all possible overloaded variants of a given instruction. The placeholder \texttt{\_} describes an unused operand. The syntax \texttt{x = y | z} describes a type alias \texttt{x} which can take on the listed types (\texttt{y} or \texttt{z}). }
    \label{tab:opcodes}
\end{table}


\section{IR interpreter}

An interpreter for the intermediate representation is available as part of the test suite to allow for testing of the generated IR without compiling it to native code. It allows for catching IR generation errors early and testing the compiler without later phases. The interpreter works directly with the IR registers and keeps track of their types and reference counts during the runtime. Reference counts are updated for all types of values, including all primitive values, which allows for checking the correctness of the generated code.

The interpreter interacts with QuickJS to keep track of JavaScript objects and perform some operations.
