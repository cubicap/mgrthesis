\chapter{Intermediate Representation}

The proposed compiler works in multiple stages and uses different representations for the products generated by each stage. This chapter describes the first intermediate representation which is generated from an AST.

In the intermediate representation, the input program is split into individual functions. The intermediate representation represents a function in the form of a control-flow graph (CFG). A CFG typically consists of basic blocks which form small chunks of linear code. Each basic block ends with a terminator instruction which can either perform a (conditional) jump to a different basic block, or terminate the whole function. Together, basic blocks (nodes) with jump instructions (edges) form a directed graph which represents all possible paths through the program.

The semantics of the program described using the intermediate representation is defined in the form of an abstract virtual machine which can execute this code.

\section{Virtual machine semantics}

The virtual machine consists of:
\begin{itemize}
    \item program code,
    \item an instruction pointer,
    \item an unlimited number of virtual registers,
    \item a cleanup stack, and
    \item a reference to a JavaScript virtual machine instance.
\end{itemize}

The virtual machine can execute a single function with the given call arguments. Each step of the execution performs a single instruction at the position of the instruction pointer and updates the instruction pointer accordingly. A \texttt{Call} instruction is not processed by the same machine. Instead, the virtual machine is paused until the call is finished by the correct means (e.g., as a native call, in a new virtual machine).

To simplify the process of generating the IR, the virtual machine uses an unlimited number of virtual registers. These will be referred to as \textit{IR registers}. IR registers should not be confused with machine registers, as they can hold different, in some cases complex, value types, which are only later mapped into the physical memory or registers. IR registers are statically typed and can take on the types described in Section \ref{ir:types}. Each register has a unique identifier represented by a numeric value.

A cleanup stack is a piece of memory which allows the program to simplify the management of value ownership. When the reference count of a value should be reduced, it is not done directly because more complex analysis of the usage of the value would be necessary. Instead, the value is placed onto the cleanup stack and its reference count is reduced at the exit of the function.

Some instructions need to interact with the underlying JavaScript virtual machine to perform the operation which they represent. A reference to the JavaScript virtual machine must be therefore accessible. The model does not specify how the JS VM will be available, but two possible approaches would be:
\begin{itemize}
    \item a constant in static memory - a function is bound to a JS VM at compile time, or
    \item through a function parameter - a function may be shared with multiple JS VMs.
\end{itemize}


\section{IR Types}\label{ir:types}

The types used by the IR are chosen as a middle point between standard JavaScript types and typical native types. This allows some primitive types to be represented without the need of a "tag" to distinguish between different types available in JavaScript which can lead to a faster runtime performance and smaller memory usage. Some newly introduced primitive types can also provide faster implementation of, for example, arithmetic operations at the cost of not conforming with the ECMAScript specification. The list of available types can be seen in Table \ref{tab:types}.
\todo{move part to language specification}

\begin{table}[H]
    \centering
    \begin{tabular}{l | l}
        Type name   & Possible values                                                \\\hline
        \texttt{Void}        & the JavaScript value \texttt{undefined}                        \\
        \texttt{Int32}       & Signed 32-bit integer number                                   \\
        \texttt{Float}       & IEEE 754-2019 double-precision floating point number          \\
        \texttt{Bool}        & true/false                                                     \\
        \texttt{Object}      & Reference to a JavaScript Object (primitive type not \\
                             & allowed)  \\
        \texttt{StringConst} & Reference to a static string value                             \\
        \texttt{String}      & Reference to a reference-counted string value                  \\
        \texttt{Any}         & Value of JavaScript's dynamic type (type union)
    \end{tabular}
    \caption{Possible types of intermediate registers}
    \label{tab:types}
\end{table}


\section{IR Instructions}

IR instructions represent simple operations and may have different variants based on types of their operands. These operations correspond to different operations from the modified JavaScript as described in a later section\todo{link our js specification}. There are four kinds of instructions:


\texttt{Operation} represents a simple instruction with up to three operands (typically 2 inputs and 1 output) and may perform different operations depending on their argument types. All operands must be IR registers, or must be ignored by a given instruction.

\texttt{ConstInit} performs a constant initialization of an IR register. They only have two operands - an IR register, and an immediate value. The types of these values correspond to primitive value literals - i.e., Bool, Int32, Float, StringConst.

\texttt{Call} represents a function call. These can have a variable number of parameters and can describe a native function call or JavaScript function call. All operands representing arguments and return target must be IR registers. The call target may either be a string identifier of a native function, or an IR register containing a function object\todo{not implemented}. The types of IR registers representing arguments and return value must correspond to the respective types defined in the signature of the called function.

\texttt{Terminator} terminates a basic block. They can be used to describe control flow.


\begin{table}
    \centering
    \begin{tabular}{l | l | l}
        \texttt{Opcode}      & Signature \texttt{(a b -> res)}    &  Meaning                    \\\hline
        \texttt{Add}         & \texttt{a      a     -> a        } &  Addition                   \\
        \texttt{Sub}         & \texttt{a      a     -> a        } &  Subtraction                \\
        \texttt{Mul}         & \texttt{a      a     -> a        } &  Multiplication             \\
        \texttt{Div}         & \texttt{a      a     -> a        } &  Division                   \\
        \texttt{Rem}         & \texttt{a      a     -> a        } &  Remainder                  \\
        \texttt{Pow}         & \texttt{a      a     -> a        } &  Exponentiation             \\
        \texttt{LShift}      & \texttt{Int32  Int32 -> Int32    } &  Left shift                 \\
        \texttt{RShift}      & \texttt{Int32  Int32 -> Int32    } &  Right shift                \\
        \texttt{URShift}     & \texttt{Int32  Int32 -> Int32    } &  Unsigned right shift       \\
        \texttt{BitAnd}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise AND                \\
        \texttt{BitOr}       & \texttt{Int32  Int32 -> Int32    } &  Bitwise OR                 \\
        \texttt{BitXor}      & \texttt{Int32  Int32 -> Int32    } &  Bitwise XOR                \\
        \texttt{Eq}          & \texttt{a      a     -> Bool     } &  Equality                   \\
        \texttt{Neq}         & \texttt{a      a     -> Bool     } &  Non-equality               \\
        \texttt{Gt}          & \texttt{a      a     -> Bool     } &  Greater than               \\
        \texttt{Gte}         & \texttt{a      a     -> Bool     } &  Greater-or-equal           \\
        \texttt{Lt}          & \texttt{a      a     -> Bool     } &  Less than                  \\
        \texttt{Lte}         & \texttt{a      a     -> Bool     } &  Less-or-equal              \\
        \texttt{GetMember}   & \texttt{parent id    -> Any      } &  Get member                 \\
        \texttt{SetMember}   & \texttt{id     a     -> parent   } &  Set member                 \\
                             & \texttt{id = StringConst | Int32 } &                             \\
                             & \texttt{parent = Object | Any    } &                             \\
        \texttt{Set}         & \texttt{a      \_    -> b        } &  Set IR register, convert   \\
        \texttt{BoolNot}     & \texttt{a      \_    -> Bool     } &  Logical negation           \\
        \texttt{BitNot}      & \texttt{Int32  \_    -> Int32    } &  Bitwise negation           \\
        \texttt{UnPlus}      & \texttt{a      \_    -> Number   } &  Unary plus                 \\
        \texttt{UnMinus}     & \texttt{a      \_    -> a        } &  Unary minus                \\
        \texttt{Dup}         & \texttt{a      \_    -> \_       } &  Increment reference count  \\
        \texttt{PushFree}    & \texttt{a      \_    -> \_       } &  Push to the cleanup stack  \\
    \end{tabular}
    \caption{Table: List of Operations. The column signature shows the possible types of IR registers used as operands. Most Operations have three operands - two inputs and one output. Therefore, the three operands are denoted as \texttt{a b -> res}. Type placeholders are used to show all possible overloaded variants of a given Operation. The placeholder \texttt{\_} describes an unused operand. The syntax \texttt{id = StringConst | Int32} describes a type alias \texttt{id} which can take on the listed types (\texttt{StringConst} or \texttt{Int32}). }
    \label{tab:opcodes}
\end{table}

The arithmetic Operations implement the operations as described in Chapter \ref{language}.

The Operations \texttt{Dup} and \texttt{PushFree}\footnotemark[1] are used for updating the reference counts\footnotemark[2] of JavaScript values. To simplify the process of decreasing the reference counts, a cleanup stack is used at runtime. The \texttt{Dup} instruction immediately increments the reference count of a value, whereas the \texttt{PushFree} instruction only pushes the value to the "cleanup" stack, which is used in function's epilogue to decrease the reference counts of all values used during it runtime. To create an equivalent machine code, numeric values should be represented as \texttt{Float}, or \texttt{Any}\todo{not implemented}\footnotemark[3].

\footnotetext[1]{The names \texttt{Dup} and \texttt{Free} are not entirely descriptive of the operation which they perform, however, an equivalent operation in QuickJS is performed by a pair of functions \texttt{JS\_DupValue} and \texttt{JS\_FreeValue}, from the names are adapted.}

\footnotetext[2]{While we talk about reference counts of values, the interface is not limited to this memory management approach. In practice, the underlying JavaScript interpreter may use a different algorithm (such as mark-and-sweep). In essence \texttt{Dup} and \texttt{PushFree} instructions only describe the action of taking and releasing the ownership of a value.}

\footnotetext[3]{The performance of arithmetic operations on different types may vary depending on the target CPU - for example, on a 32-bit CPU without 64-bit float acceleration, work with small integer values will be significantly faster when the \texttt{Any} type is used instead of \texttt{Float}.}


\section{IR interpreter}

An interpreter for the intermediate representation is available as a part of the test suite to allow for testing of the generated IR without compiling it to the native code. It allows for catching IR generation errors early and for avoiding the debugging of the final machine code. The interpreter works directly with the immediate variables and keeps track of their types and reference counts\todo{extend for primitives} during the runtime.
