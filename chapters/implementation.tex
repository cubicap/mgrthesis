\chapter{Implementation}

The compilation pipeline consists of multiple stages. The input is the content of a single TypeScript file, and the output is runnable JavaScript code with stubs referring to generated native functions.


\section{Parser}

The first stage of the compilation pipeline involves parsing the input source code. The TypeScript code is converted to an asymptotic syntax tree (AST) using a recursive descent parser. The design of its implementation is inspired by the parser described in the book \textit{Crafting Interpreters}\cite{craftinginterpreters}.

Because the language grammar is left recursive, as described in Section \texttt{grammar}, slight modifications to the grammar and the algorithm are needed.

Infix binary expressions, in particular, are parsed using a cover grammar which is later refined into the correct expression tree. In general, a cover grammar is a more general grammar which is easier to parse but may not produce an equivalent parse tree. The cover grammar is then refined into the correct parse tree using a separate algorithm. The cover grammar used for parsing infix binary expressions is defined as follows:

\begin{minted}{text}
    BinaryExpression -> UnaryExpression [ op BinaryExpression ]*
    op -> infix operator token
\end{minted}

The result is refined according to the operator precedence and associativity to the correct expression tree using the Shunting Yard algorithm\cite{algol60}.

Another case of left recursion in the grammar are the non-terminals \texttt{MemberExpression} and \texttt{CallExpression}. In both cases, there are multiple productions with left recursion. Fortunately, all of these productions represent a repeated application of a rule. Therefore, they can be parsed iteratively and then transformed into the corresponding syntax tree. The non-left recursive productions are always applied first, and the left recursive productions are applied in a loop until no more productions can be applied. The grammar for these two non-terminals is defined as follows:

\begin{minted}{text}
    MemberExpression -> SuperProperty
    MemberExpression -> MetaProperty
    MemberExpression -> PrimaryExpression
    MemberExpression -> MemberExpression [ Expression ]
    MemberExpression -> MemberExpression . IdentifierName
    MemberExpression -> MemberExpression . PrivateIdentifier
    MemberExpression -> MemberExpression TemplateLiteral
    MemberExpression -> new MemberExpression Arguments

    CallExpression -> SuperCall
    CallExpression -> ImportCall
    CallExpression -> MemberExpression Arguments
    CallExpression -> CallExpression [ Expression ]
    CallExpression -> CallExpression . IdentifierName
    CallExpression -> CallExpression . PrivateIdentifier
    CallExpression -> CallExpression TemplateLiteral
\end{minted}

The remaining left recursive productions represent simple lists of items and can be, again, parsed iteratively. These non-terminal are: \texttt{FormalParameters}, \texttt{Expression} (comma operator), \texttt{LexicalDeclaration}, \texttt{VariableDeclaration}, \texttt{Arguments}, and \texttt{StatementList}.

After generating the AST, the top level statement list is traversed, some function declarations are selected for compilation and processed by the next stage.


\section{Generating the intermediate representation}

Every function in the AST consists of two parts: a signature and a body. First, the IR generator iterates over all function declarations and creates a list of all possibly compilable functions. In this step, a function is considered compilable if the function signature contains type annotations for all parameters and the return type. The list allows the generator to determine which functions are to be compiled and to insert native calls in relevant places. Then, the function bodies are processed independently on a per-function basis. If compilation of one of these functions fails, the whole compilation process fails with a `SyntaxError` exception and the input program cannot be executed.

The statements in the function body are recursively traversed by the compiler and the AST is transformed into the intermediate representation described in Chapter \ref{ir}.

The IR generator is implemented as a number of functions which describe the generation process for different AST nodes. These functions operate on the top a shared state object which keeps track of the context of IR generation, in particular, lexical and variable declarations and their scopes, active basic block, break and continue targets, and the whole CFG that is being created.

There are two kinds of AST nodes that generate a part of the IR code -- statements and expressions. When an AST node is being processed, all of its children get processed recursively. In the case of expressions, the sub-nodes have a value result, which may be used in some way by the parent node. The results can have different value types can be used in different ways. Some may be used as assignment targets (l-values) and some may be only used as value operands in another expression (r-values). When l-values are to be used as value operands in another expression, they first have to be evaluated (their value is acquired).

Because some AST nodes may result in different value types depending on the whole subtree, a third, union type is used as a result for a later disambiguation. In the implementation, they are represented by the following structures:
\begin{itemize}
\item \texttt{RValue} which represents an r-value,
\item \texttt{LVRef} which represents an l-value, and
\item \texttt{Value} which represents a union of the two above.
\end{itemize}

Sometimes, the final value type of evaluated sub-node can be incompatible with what the parent node expects. In these cases, the input code contains syntax error, because static semantics of the language are violated. The IR generator will then throw a \texttt{SyntaxError} exception and abort the compilation process.

When a value is saved into an IR register, its reference count needs to be updated. This operation is implemented by a \texttt{Dup} instruction which is emitted. The reference count needs to be decreased after the value is no longer needed. To avoid analyzing the code and finding the correct places to perform this task, the value is saved using the \texttt{PushFree} instruction and the reference count is decreased before returning from the function.

The process of generating the IR code itself can be viewed as two simple cases -- linear code, and branching code. Generating linear code is trivial, as the respective AST nodes are simply replaced by their counterparts consisting of the IR instructions. These can be directly emitted to the currently active basic block.

When generating branching code, the active basic block has to be split into two parts -- entry, and exit. The entry block contains the original code without a terminator instruction while the exit block retains only the terminator instruction. The branching code is then simply emitted into the entry block and a number of newly created blocks for all new paths. Paths that do not terminate, or contain non-linear\todo{check} control flow (i.e., \texttt{break} or \texttt{continue} statements) must all converge to the exit block.

\subsection{Examples of IR generation}

\todo{show the IR-gen of some significant AST nodes -- linear expression, if, for, short-circuit expression, terminating statement}

\subsection{Runtime requirements of IR function}\todo{find a better title}\label{subsec:irruntime}

There are very few requirements on how a function represented by the intermediate representation should behave. The values in IR registers can be stored in any way, be it in machine registers, in stack memory, or in some entirely different way. There is also no standardized calling convention. The execution environment must only arrange for the function arguments to be passed to the correct IR registers, and the return value to be passed back to the caller.\todo{move to IR chapter?}

A function in the IR requires access to the instance of the JavaScript interpreter it runs under. To implement the \texttt{PushFree} instruction, it also needs a secondary stack (or another container) for storing all values that need to be freed at exit.


\section{Compiler backend}

The compiler relies on the MIR compiler backend to perform register allocation, code generation, and optimization of the machine code. MIR generates functions with a standard calling convention for a target platform. This calling convention, however, is not compatible with the signature of functions expected by QuickJS. Therefore, for every compiled function, a companion function with a compatible interface is generated.

The MIR code is generated by simply replacing parts of the IR with the respective MIR representation. Some simple instructions can be replaced by a single MIR instruction, some more complex are replaced by multiple MIR instructions or a function call.

The final, native, functions require a runtime context, as described in Section \ref{subsec:irruntime}. The context primarily contains a pointer to an instance of the JavaScript interpreter. It also contains a secondary stack used by the \texttt{PushFree} instruction. Lastly, it holds the values of all string constants used by the compiled functions. As these functions exist only in the context of a single JavaScript interpreter, all functions use the same global context through a global constant pointer that is linked to them.


\section{Stubs}\todo{check name}\label{stubs}

After compiling the functions to the native code, they need to be made accessible from the interpreter. The compiled functions are therefore wrapped in JavaScript function objects (stubs) which are then defined as properties of JavaScript's global object\footnotemark[1] with unique identifiers.

\footnotetext[1]{In JavaScript, a global object is a special object \texttt{globalThis} which is globally accessible from an execution context (i.e., including different modules). Properties of the global object are a part of the lexical scope, and one of its functions is to provide intrinsic objects and values to the execution environment.}

A new JavaScript source code is also generated. In this source code, the declarations of compiled functions are replaced by references to the stubs, and by comments with the original function's source code.

JavaScript applies declaration and value hoisting on function declarations. This means that in a standard JavaScript program, it is possible to reference and use a function before it is declared. In the newly generated code, we can only replicate this behavior by declaring a new function which would call the stub function. Declaring a new function would result in a new level of indirection in every call of this function and induce an unnecessary overhead.

As maintaining JavaScript's behavior is, in this case, not feasible without modifying the underlying interpreter, we have elected to change the behavior instead. For declaring the aliases for the stub functions, we use a constant lexical declaration (i.e., \texttt{const}). While the runtime semantics is slightly different, its also disallows users from rebinding the same name to a different function (or value). Such behavior is potentially dangerous, because at compile time functions are statically linked to each other. If a user rebound a function name which was referenced from a different compiled function, they might expect a change in behavior of the compiled function which would, however, not happen. By declaring the function reference as \texttt{const}, such code would result in a type error.


\section{Interpreter}

The newly generated JavaScript code is then executed by the interpreter which is unmodified QuickJS with Jaculus-machine abstraction layer. After preprocessing the source code as described before and defining new properties of the JavaScript's global object, the new JavaScript code is executed as normal.

\section{Integration with Jaculus-machine}

Jaculus-machime uses a modular approach which allows a programmer to select which modules should be a part of a JavaScript runtime (called \textit{Machine}). Jaculus-machine calls these modules \textit{MFeatures}. The configuration of a selected set of MFeatures is performed at compile time which allows the individual MFeatures to interact with one another without a significant overhead caused by dynamic linkage.

The compiler implementation is provided as a single MFeature, which provides a method \texttt{eval} for executing input source code. The source code is always processed by the compiler and the generated code is executed.
